{"version":3,"file":"photos-src_mixins_FaceCoverMixin_js-src_mixins_FetchFacesMixin_js.js?v=32ecf436be4947895a5d","mappings":";;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;ACrGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sources":["webpack:///photos/src/mixins/FaceCoverMixin.js","webpack:///photos/src/mixins/FetchFacesMixin.js"],"sourcesContent":["function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n/**\n * @copyright Copyright (c) 2022 Marcel Klehr <mklehr@gmx.net>\n *\n * @author Marcel Klehr <mklehr@gmx.net>\n *\n * @license AGPL-3.0-or-later\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License as\n * published by the Free Software Foundation, either version 3 of the\n * License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n * GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see <http://www.gnu.org/licenses/>.\n *\n */\nimport { mapGetters } from 'vuex';\nimport he from 'he';\nexport default {\n  name: 'FaceCoverMixin',\n  computed: _objectSpread({}, mapGetters(['faces', 'facesFiles', 'files'])),\n  methods: {\n    getFaceCover: function getFaceCover(faceName) {\n      var _this = this;\n\n      // Give high scores for faces that intersect with the edge of the picture (with a margin of half the face size)\n      var scoreFacePosition = function scoreFacePosition(faceDetection) {\n        return Math.max(0, -1 * (faceDetection.x - faceDetection.width * 0.5)) + Math.max(0, -1 * (faceDetection.y - faceDetection.height * 0.5)) + Math.max(0, -1 * (1 - (faceDetection.x + faceDetection.width) - faceDetection.width * 0.5)) + Math.max(0, -1 * (1 - (faceDetection.y + faceDetection.height) - faceDetection.height * 0.5));\n      };\n\n      return (this.facesFiles[faceName] || []).slice(0, 25).map(function (fileId) {\n        return _this.files[fileId];\n      }).map(function (file) {\n        return _objectSpread(_objectSpread({}, file), {}, {\n          faceDetections: JSON.parse(he.decode(file.faceDetections))\n        });\n      }) // sort larges face first\n      .sort(function (a, b) {\n        return b.faceDetections.find(function (d) {\n          return d.title === faceName;\n        }).width - a.faceDetections.find(function (d) {\n          return d.title === faceName;\n        }).width;\n      }) // sort fewest face detections first\n      .sort(function (a, b) {\n        return a.faceDetections.length - b.faceDetections.length;\n      }) // Sort faces that are at the edge last\n      .sort(function (a, b) {\n        return scoreFacePosition(a.faceDetections.find(function (d) {\n          return d.title === faceName;\n        })) - scoreFacePosition(b.faceDetections.find(function (d) {\n          return d.title === faceName;\n        }));\n      })[0];\n    },\n\n    /**\n     * This will produce an inline style to apply to images\n     * to zoom toward the detected face\n     *\n     * @param faceName\n     * @return {{}|{transform: string, width: string, transformOrigin: string}}\n     */\n    getCoverStyle: function getCoverStyle(faceName) {\n      var cover = this.getFaceCover(faceName);\n\n      if (!cover) {\n        return {};\n      }\n\n      var detections = cover.faceDetections;\n      var detection = detections.find(function (detection) {\n        return detection.title === faceName;\n      }); // Zoom into the picture so that the face fills the --photos-face-width box nicely\n      // if the face is larger than the image, we don't zoom out (reason for the Math.max)\n\n      var zoom = Math.max(1, 1 / detection.width * 0.4);\n      var horizontalCenterOfFace = (detection.x + detection.width / 2) * 100;\n      var verticalCenterOfFace = (detection.y + detection.height / 2) * 100;\n      return {\n        // We assume that the image is inside a div with width: var(--photos-face-width)\n        width: '100%',\n        // we translate the image so that the center of the detected face is in the center of the --photos-face-width box\n        // and add the zoom\n        transform: \"translate(calc( var(--photos-face-width)/2 - \".concat(horizontalCenterOfFace, \"% ), calc( var(--photos-face-width)/2 - \").concat(verticalCenterOfFace, \"% )) scale(\").concat(zoom, \")\"),\n        // this is necessary for the zoom to zoom toward the center of the face\n        transformOrigin: \"\".concat(horizontalCenterOfFace, \"% \").concat(verticalCenterOfFace, \"%\")\n      };\n    }\n  }\n};","function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\n\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\n\n/**\n * @copyright Copyright (c) 2022 Louis Chemineau <louis@chmn.me>\n *\n * @author Louis Chemineau <louis@chmn.me>\n *\n * @license AGPL-3.0-or-later\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License as\n * published by the Free Software Foundation, either version 3 of the\n * License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n * GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see <http://www.gnu.org/licenses/>.\n *\n */\nimport { mapActions, mapGetters } from 'vuex';\nimport { showError } from '@nextcloud/dialogs';\nimport { getCurrentUser } from '@nextcloud/auth';\nimport client from '../services/DavClient.js';\nimport logger from '../services/logger.js';\nimport DavRequest from '../services/DavRequest';\nimport { genFileInfo } from '../utils/fileUtils';\nimport AbortControllerMixin from './AbortControllerMixin';\nexport default {\n  name: 'FetchFacesMixin',\n  data: function data() {\n    return {\n      errorFetchingFaces: null,\n      loadingFaces: false,\n      errorFetchingFiles: null,\n      loadingFiles: false\n    };\n  },\n  mixins: [AbortControllerMixin],\n  beforeMount: function beforeMount() {\n    var _this = this;\n\n    return _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {\n      return regeneratorRuntime.wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              _this.fetchFaces();\n\n            case 1:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee);\n    }))();\n  },\n  computed: _objectSpread({}, mapGetters(['faces'])),\n  methods: _objectSpread(_objectSpread({}, mapActions(['appendFiles'])), {}, {\n    fetchFaces: function fetchFaces() {\n      var _this2 = this;\n\n      return _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {\n        var _getCurrentUser, faces;\n\n        return regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                if (!_this2.loadingFaces) {\n                  _context2.next = 2;\n                  break;\n                }\n\n                return _context2.abrupt(\"return\");\n\n              case 2:\n                if (!Object.keys(_this2.faces).length) {\n                  _context2.next = 4;\n                  break;\n                }\n\n                return _context2.abrupt(\"return\");\n\n              case 4:\n                _context2.prev = 4;\n                _this2.loadingFaces = true;\n                _this2.errorFetchingFaces = null;\n                _context2.next = 9;\n                return client.getDirectoryContents(\"/recognize/\".concat((_getCurrentUser = getCurrentUser()) === null || _getCurrentUser === void 0 ? void 0 : _getCurrentUser.uid, \"/faces/\"), {\n                  signal: _this2.abortController.signal\n                });\n\n              case 9:\n                faces = _context2.sent;\n\n                _this2.$store.dispatch('addFaces', {\n                  faces: faces\n                });\n\n                logger.debug(\"[FetchFacesMixin] Fetched \".concat(faces.length, \" new faces: \"), faces);\n                _context2.next = 19;\n                break;\n\n              case 14:\n                _context2.prev = 14;\n                _context2.t0 = _context2[\"catch\"](4);\n\n                if (_context2.t0.response && _context2.t0.response.status) {\n                  if (_context2.t0.response.status === 404) {\n                    _this2.errorFetchingFaces = 404;\n                  } else {\n                    _this2.errorFetchingFaces = _context2.t0;\n                  }\n                }\n\n                logger.error(t('photos', 'Failed to fetch faces list.'), _context2.t0);\n                showError(t('photos', 'Failed to fetch faces list.'));\n\n              case 19:\n                _context2.prev = 19;\n                _this2.loadingFaces = false;\n                return _context2.finish(19);\n\n              case 22:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, null, [[4, 14, 19, 22]]);\n      }))();\n    },\n    fetchFaceContent: function fetchFaceContent(faceName, force) {\n      var _this3 = this;\n\n      return _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3() {\n        var _getCurrentUser2, _yield$client$getDire, fetchedFiles, fileIds;\n\n        return regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                if (!_this3.loadingFiles) {\n                  _context3.next = 2;\n                  break;\n                }\n\n                return _context3.abrupt(\"return\");\n\n              case 2:\n                if (!(!force && _this3.facesFiles[faceName] && _this3.facesFiles[faceName].length)) {\n                  _context3.next = 4;\n                  break;\n                }\n\n                return _context3.abrupt(\"return\");\n\n              case 4:\n                _context3.prev = 4;\n                _this3.errorFetchingFiles = null;\n                _this3.loadingFiles = true;\n                _context3.next = 9;\n                return client.getDirectoryContents(\"/recognize/\".concat((_getCurrentUser2 = getCurrentUser()) === null || _getCurrentUser2 === void 0 ? void 0 : _getCurrentUser2.uid, \"/faces/\").concat(faceName), {\n                  data: DavRequest,\n                  details: true,\n                  signal: _this3.abortController.signal\n                });\n\n              case 9:\n                _yield$client$getDire = _context3.sent;\n                fetchedFiles = _yield$client$getDire.data;\n                fetchedFiles = fetchedFiles.map(function (file) {\n                  return genFileInfo(file);\n                }).map(function (file) {\n                  return _objectSpread(_objectSpread({}, file), {}, {\n                    filename: file.realpath.replace(\"/\".concat(getCurrentUser().uid, \"/files\"), '')\n                  });\n                });\n                fileIds = fetchedFiles.map(function (file) {\n                  return '' + file.fileid;\n                });\n\n                _this3.appendFiles(fetchedFiles);\n\n                if (!(fetchedFiles.length > 0)) {\n                  _context3.next = 17;\n                  break;\n                }\n\n                _context3.next = 17;\n                return _this3.$store.commit('addFilesToFace', {\n                  faceName: faceName,\n                  fileIdsToAdd: fileIds\n                });\n\n              case 17:\n                logger.debug(\"[FetchFacesMixin] Fetched \".concat(fileIds.length, \" new files: \"), fileIds);\n                _context3.next = 24;\n                break;\n\n              case 20:\n                _context3.prev = 20;\n                _context3.t0 = _context3[\"catch\"](4);\n\n                if (_context3.t0.response && _context3.t0.response.status) {\n                  if (_context3.t0.response.status === 404) {\n                    _this3.errorFetchingFiles = 404;\n                  } else {\n                    _this3.errorFetchingFiles = _context3.t0;\n                  }\n                } // cancelled request, moving on...\n\n\n                logger.error('Error fetching face files', _context3.t0);\n\n              case 24:\n                _context3.prev = 24;\n                _this3.loadingFiles = false;\n                return _context3.finish(24);\n\n              case 27:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, null, [[4, 20, 24, 27]]);\n      }))();\n    }\n  })\n};"],"names":[],"sourceRoot":""}